"""
Backtesting Framework for the Fibonacci Cycle Trading System.

This module provides a comprehensive backtesting framework that properly integrates with 
the core cycle detection, FLD analysis, and signal generation components. It allows for:

1. Testing trading strategies on historical data
2. Evaluating entry/exit signals from the core analysis engine
3. Calculating performance metrics
4. Visualizing backtest results

The framework is designed to accurately reflect the dynamics of the core analysis
components, ensuring that backtest results are representative of the actual 
trading signals generated by the system.
"""

import os
import sys
import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Union, Tuple, Any
from dataclasses import dataclass
import logging
from datetime import datetime, timedelta
import time
import json
import matplotlib.pyplot as plt
from collections import defaultdict

# Add project root to path if not already there
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

# Import from absolute paths with better error handling
try:
    from utils.logging_utils import get_component_logger
    logger = get_component_logger("backtesting.backtesting_framework")
except ImportError:
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("backtesting.backtesting_framework")

@dataclass
class BacktestTrade:
    """Class to represent a completed backtest trade."""
    symbol: str
    direction: str  # 'long' or 'short'
    entry_date: datetime
    entry_price: float
    exit_date: datetime
    exit_price: float
    quantity: float
    profit_loss: float
    profit_loss_pct: float
    exit_reason: str
    # Additional data for analysis
    signal_strength: float = 0.0
    signal_alignment: float = 0.0
    cycle_state: Optional[Dict] = None
    cycles: Optional[List[int]] = None


@dataclass
class BacktestParameters:
    """Parameters for backtesting."""
    symbol: str
    exchange: str
    interval: str
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    lookback: int = 1000
    num_cycles: int = 3
    price_source: str = "close"
    initial_capital: float = 100000.0
    position_size_pct: float = 10.0
    max_open_positions: int = 5
    trailing_stop: bool = False
    trailing_stop_pct: float = 5.0
    take_profit_multiplier: float = 2.0  # R:R ratio
    rebalance_frequency: Optional[str] = None  # 'daily', 'weekly', 'monthly'
    require_alignment: bool = True
    min_strength: float = 0.2
    pyramiding: int = 0  # Number of additional entries allowed
    strategy_type: str = "fib_cycle"  # Strategy type to use for backtesting
    commission_pct: float = 0.05  # Commission percentage (per trade value)
    slippage_pct: float = 0.02  # Slippage percentage (per trade value)
    capital_allocation_mode: str = "percentage"  # 'fixed' or 'percentage'


class BacktestEngine:
    """
    Advanced Backtesting Engine for the Fibonacci Cycle Trading System.
    
    This engine is deeply integrated with the core cycle detection, FLD analysis,
    and signal generation capabilities of the system. It provides accurate simulation
    of how the trading strategies would perform on historical data.
    """
    
    def __init__(self, 
                 config: Dict,
                 scanner=None, 
                 data_fetcher=None):
        """
        Initialize the backtesting engine.
        
        Args:
            config: Configuration dictionary for the system
            scanner: Optional scanner instance (will be imported if not provided)
            data_fetcher: Optional data fetcher instance (will be imported if not provided)
        """
        self.config = config
        
        # Dynamically import dependencies to avoid circular imports
        if scanner is None:
            try:
                from core.scanner_system import FibCycleScanner
                self.scanner = FibCycleScanner(config)
            except ImportError as e:
                logger.error(f"Error importing FibCycleScanner: {e}")
                raise ImportError("Could not import scanner. Make sure it's in your PYTHONPATH.")
        else:
            self.scanner = scanner
            
        if data_fetcher is None:
            try:
                from data.data_management import DataFetcher
                self.data_fetcher = DataFetcher(config)
            except ImportError as e:
                logger.error(f"Error importing DataFetcher: {e}")
                raise ImportError("Could not import data fetcher. Make sure it's in your PYTHONPATH.")
        else:
            self.data_fetcher = data_fetcher
            
        # Import other necessary components
        try:
            from models.scan_parameters import ScanParameters
            self.ScanParameters = ScanParameters
        except ImportError:
            logger.error("Could not import ScanParameters")
            raise
            
        try:
            from trading.trading_strategies import get_strategy_by_name
            self.get_strategy_by_name = get_strategy_by_name
        except ImportError:
            logger.warning("Could not import trading strategies module. Using default strategy.")
            self.get_strategy_by_name = lambda x: None
            
        # Initialize internal state
        self.results_cache = {}
    
    def run_backtest(self, params: BacktestParameters) -> Dict:
        """
        Run a backtest with the specified parameters.
        
        This method orchestrates the entire backtesting process:
        1. Fetching historical data
        2. Processing it through the core analysis engine
        3. Simulating trade execution based on signals
        4. Calculating performance metrics
        
        Args:
            params: BacktestParameters containing all settings for the backtest
            
        Returns:
            Dictionary containing comprehensive backtest results
        """
        logger.info(f"Starting backtest for {params.symbol} on {params.interval} timeframe")
        start_time = time.time()
        
        try:
            # Step 1: Get historical market data
            data = self._get_historical_data(params)
            if data is None or data.empty:
                return {
                    "success": False,
                    "error": f"Could not retrieve data for {params.symbol} ({params.exchange}, {params.interval})"
                }
                
            logger.info(f"Retrieved {len(data)} bars for backtest")
            
            # Step 2: Initialize tracking variables
            equity_curve = []
            trades = []
            positions = {}  # Currently open positions
            current_capital = params.initial_capital
            available_capital = params.initial_capital
            history = []  # Track system state at each point
            
            # Step 3: Process each bar sequentially (to avoid lookahead bias)
            safe_lookback = min(params.lookback, len(data) - 1)
            if safe_lookback != params.lookback:
                logger.warning(f"Adjusted processing lookback from {params.lookback} to {safe_lookback} due to data size")
                
            # Important: We start from lookback to ensure enough data for analysis
            for i in range(safe_lookback, len(data)):
                current_date = data.index[i]
                current_bar = data.iloc[i]
                
                # Get the historical slice up to this point (includes current bar)
                historical_slice = data.iloc[:i+1].copy()
                
                # Step 3.1: Update open positions
                trade_updates = self._update_positions(
                    positions=positions,
                    current_bar=current_bar,
                    current_date=current_date,
                    params=params
                )
                
                # Update capital and positions
                closed_positions = trade_updates['closed_positions']
                trades.extend(trade_updates['closed_trades'])
                current_capital = trade_updates['updated_capital']
                available_capital = current_capital - trade_updates['allocated_capital']
                
                # Step 3.2: Run core analysis on the current slice
                if len(positions) < params.max_open_positions:  # Only analyze if we can open new positions
                    # Create scan parameters 
                    scan_params = self.ScanParameters(
                        symbol=params.symbol,
                        exchange=params.exchange,
                        interval=params.interval,
                        lookback=safe_lookback,  # Use adjusted lookback
                        num_cycles=params.num_cycles,
                        price_source=params.price_source,
                        generate_chart=False  # No need for charts in backtest
                    )
                    
                    # Run the analysis on this historical slice
                    # We use custom data to avoid lookahead bias
                    scan_params.custom_data = historical_slice  
                    
                    # Get analysis results
                    analysis_result = self.scanner.analyze_symbol(scan_params)
                    
                    # Step 3.3: Check for entry signals
                    if analysis_result.success and self._should_enter_position(analysis_result, params):
                        # Calculate position size
                        position_size = self._calculate_position_size(
                            available_capital=available_capital,
                            current_price=current_bar[params.price_source],
                            analysis_result=analysis_result,
                            params=params
                        )
                        
                        # Enter new position
                        if position_size > 0:
                            new_position = self._enter_position(
                                analysis_result=analysis_result,
                                current_date=current_date,
                                current_bar=current_bar, 
                                position_size=position_size,
                                params=params
                            )
                            
                            # Add to positions
                            position_id = f"{params.symbol}_{len(positions)}_{current_date.strftime('%Y%m%d')}"
                            positions[position_id] = new_position
                            
                            # Update available capital
                            allocated_capital = new_position['allocated_capital']
                            commission = allocated_capital * (params.commission_pct / 100)
                            available_capital -= (allocated_capital + commission)
                            current_capital -= commission
                
                # Step 3.4: Record state for this bar
                total_positions_value = sum(p.get('current_value', p.get('allocated_capital', 0)) 
                                          for p in positions.values())
                
                equity = current_capital + total_positions_value
                
                # Record the equity
                equity_curve.append({
                    'date': current_date,
                    'equity': equity,
                    'cash': current_capital,
                    'positions_value': total_positions_value,
                    'open_positions': len(positions)
                })
                
                # Record detailed history - conditionally to save memory
                if i % 5 == 0 or analysis_result.success:  # Record every 5th bar or on successful analysis
                    state = {
                        'date': current_date,
                        'bar': current_bar.to_dict(),
                        'equity': equity,
                        'positions': len(positions),
                        'signal': analysis_result.signal if analysis_result.success else None,
                        'cycles': analysis_result.detected_cycles if analysis_result.success else None
                    }
                    history.append(state)
            
            # Step 4: Close any remaining open positions at the end of the backtest
            final_bar = data.iloc[-1]
            final_date = data.index[-1]
            
            for position_id, position in list(positions.items()):
                # Close the position at the final price
                exit_price = final_bar[params.price_source]
                direction = position['direction']
                entry_price = position['entry_price']
                quantity = position['quantity']
                allocated_capital = position['allocated_capital']
                
                # Calculate profit/loss
                if direction == 'long':
                    profit_loss = (exit_price - entry_price) * quantity
                else:  # short
                    profit_loss = (entry_price - exit_price) * quantity
                
                # Apply commission
                commission = (exit_price * quantity) * (params.commission_pct / 100)
                profit_loss -= commission
                
                # Create trade record
                trade = BacktestTrade(
                    symbol=params.symbol,
                    direction=direction,
                    entry_date=position['entry_date'],
                    entry_price=entry_price,
                    exit_date=final_date,
                    exit_price=exit_price,
                    quantity=quantity,
                    profit_loss=profit_loss,
                    profit_loss_pct=(profit_loss / allocated_capital) * 100,
                    exit_reason="end_of_backtest",
                    signal_strength=position.get('signal_strength', 0),
                    signal_alignment=position.get('signal_alignment', 0),
                    cycles=position.get('cycles', [])
                )
                
                # Add to trades list
                trades.append(trade)
                
                # Update capital
                current_capital += allocated_capital + profit_loss
                
                # Remove from positions
                del positions[position_id]
            
            # Step 5: Calculate performance metrics
            if trades:
                metrics = self._calculate_performance_metrics(
                    equity_curve=equity_curve,
                    trades=trades,
                    params=params
                )
            else:
                logger.warning(f"No trades generated in backtest for {params.symbol}")
                metrics = self._empty_metrics()
            
            # Step 6: Prepare results
            execution_time = time.time() - start_time
            
            results = {
                "success": True,
                "symbol": params.symbol,
                "exchange": params.exchange,
                "interval": params.interval,
                "start_date": data.index[0],
                "end_date": data.index[-1],
                "duration_days": (data.index[-1] - data.index[0]).days,
                "bars_processed": len(data) - safe_lookback,
                "initial_capital": params.initial_capital,
                "final_capital": current_capital if not equity_curve else equity_curve[-1]['equity'],
                "trades": [self._trade_to_dict(t) for t in trades],
                "metrics": metrics,
                "equity_curve": equity_curve,
                "execution_time": execution_time,
                "params": self._params_to_dict(params)
            }
            
            logger.info(f"Backtest completed for {params.symbol}: {len(trades)} trades, " 
                       f"Return: {metrics['total_return_pct']:.2f}%, "
                       f"Time: {execution_time:.2f}s")
            
            return results
            
        except Exception as e:
            logger.error(f"Error in backtest: {str(e)}", exc_info=True)
            return {
                "success": False,
                "symbol": params.symbol,
                "exchange": params.exchange,
                "interval": params.interval,
                "error": str(e)
            }
    
    def _get_historical_data(self, params: BacktestParameters) -> pd.DataFrame:
        """
        Get historical data for the backtest period.
        
        Args:
            params: Backtest parameters
            
        Returns:
            DataFrame with historical price data
        """
        # Use the data_fetcher to get historical data
        try:
            # Try to get directly from data fetcher
            data = self.data_fetcher.get_data(
                symbol=params.symbol,
                exchange=params.exchange, 
                interval=params.interval,
                lookback=params.lookback,
                start_date=params.start_date,
                end_date=params.end_date,
                price_source=params.price_source
            )
            
            if data is None or data.empty:
                logger.warning(f"No data found for {params.symbol}. Trying alternative sources.")
                
                # Try with cached data
                try:
                    cache_file = os.path.join(
                        project_root, "data", "cache", 
                        f"{params.exchange}_{params.symbol}_{params.interval}.csv"
                    )
                    
                    if os.path.exists(cache_file):
                        logger.info(f"Loading data from cache: {cache_file}")
                        data = pd.read_csv(cache_file, index_col=0, parse_dates=True)
                        
                        # Filter for date range if specified
                        if params.start_date and params.end_date:
                            mask = (data.index >= params.start_date) & (data.index <= params.end_date)
                            data = data[mask].copy()
                            
                except Exception as cache_err:
                    logger.error(f"Error loading cached data: {cache_err}")
                
                # If still no data, try mock data generator
                if data is None or data.empty:
                    try:
                        logger.warning(f"Using mock data for {params.symbol}")
                        from data.mock_data_generator import generate_mock_price_data
                        
                        # Generate extra data to account for lookback
                        data = generate_mock_price_data(
                            symbol=params.symbol,
                            lookback=params.lookback * 2,  # Generate extra data
                            interval=params.interval
                        )
                        
                    except Exception as mock_err:
                        logger.error(f"Error generating mock data: {mock_err}")
                
            # If we have data at this point, do final processing and date filtering
            if data is not None and not data.empty:
                # Ensure data has all required columns
                required_cols = ['open', 'high', 'low', 'close', 'volume']
                for col in required_cols:
                    if col not in data.columns:
                        if col == 'volume':
                            data[col] = 0  # Default volume if missing
                        else:
                            # For price columns, copy from close if available
                            data[col] = data.get('close', data.iloc[:, 0])
                
                # Check the date range
                if params.start_date and params.end_date:
                    start = pd.Timestamp(params.start_date)
                    end = pd.Timestamp(params.end_date)
                    
                    # Keep data within specified range
                    data = data[(data.index >= start) & (data.index <= end)].copy()
                
                # Sort by date just to be sure
                data = data.sort_index()
                
                # Add 'price' column if not present (matches price_source)
                if 'price' not in data.columns:
                    data['price'] = data[params.price_source]
                
                logger.info(f"Successfully prepared data: {len(data)} bars from "
                           f"{data.index[0]} to {data.index[-1]}")
                
                return data
            
            # Still no data after all attempts
            logger.error(f"Could not retrieve data for {params.symbol} "
                        f"({params.exchange}, {params.interval})")
            return None
            
        except Exception as e:
            logger.error(f"Error fetching historical data: {e}", exc_info=True)
            return None
    
    def _should_enter_position(self, analysis_result, params: BacktestParameters) -> bool:
        """
        Determine if a new position should be entered based on analysis result.
        
        Args:
            analysis_result: Analysis result from scanner
            params: Backtest parameters
            
        Returns:
            Boolean indicating whether to enter a position
        """
        # Extract signal data
        signal = analysis_result.signal
        if not signal:
            return False
        
        signal_type = signal.get('signal', 'neutral')
        strength = signal.get('strength', 0)
        alignment = signal.get('alignment', 0)
        
        # Log evaluation for debugging
        logger.debug(f"Evaluating signal: {signal_type}, strength: {strength}, alignment: {alignment}," 
                    f" thresholds: min_strength={params.min_strength}, min_alignment={0.6 if params.require_alignment else 0}")
        
        # 1. Check signal strength
        if abs(strength) < params.min_strength:
            logger.debug(f"Signal strength too low: {abs(strength):.2f} < {params.min_strength:.2f}")
            return False
            
        # 2. Check alignment if required
        if params.require_alignment and alignment < 0.6:
            logger.debug(f"Cycle alignment too low: {alignment:.2f} < 0.6")
            return False
            
        # 3. Check signal type
        valid_buy_signals = ['strong_buy', 'buy', 'weak_buy']
        valid_sell_signals = ['strong_sell', 'sell', 'weak_sell']
        
        is_valid = (
            (signal_type in valid_buy_signals) or 
            (signal_type in valid_sell_signals)
        )
        
        # Log final decision
        logger.debug(f"Signal evaluation result: {is_valid} for {signal_type}")
        return is_valid
    
    def _calculate_position_size(self, 
                               available_capital: float,
                               current_price: float,
                               analysis_result,
                               params: BacktestParameters) -> float:
        """
        Calculate position size based on capital allocation and risk management.
        
        Args:
            available_capital: Available capital for the trade
            current_price: Current price of the asset
            analysis_result: Analysis result from scanner
            params: Backtest parameters
            
        Returns:
            Position size (quantity to trade)
        """
        if available_capital <= 0 or current_price <= 0:
            return 0
            
        # Get signal and position guidance
        signal = analysis_result.signal
        guidance = analysis_result.position_guidance
        
        # Calculate allocation based on specified mode
        if params.capital_allocation_mode == 'fixed':
            # Fixed dollar amount per trade
            trade_value = min(params.position_size_pct, available_capital)
        else:
            # Default: percentage of available capital
            trade_value = available_capital * (params.position_size_pct / 100)
        
        # Adjust trade value based on signal strength and confidence
        confidence = signal.get('confidence', 'medium')
        strength = abs(signal.get('strength', 0.5))
        
        # Scale by confidence
        confidence_multiplier = {
            'high': 1.0,
            'medium': 0.8,
            'low': 0.6
        }.get(confidence, 0.8)
        
        # Scale by strength
        strength_multiplier = min(1.0, max(0.5, strength))
        
        # Apply scaling
        adjusted_value = trade_value * confidence_multiplier * strength_multiplier
        
        # Calculate quantity
        quantity = adjusted_value / current_price
        
        # Round to appropriate precision
        if current_price > 1000:
            quantity = round(quantity, 2)  # Less precision for high-priced assets
        else:
            quantity = round(quantity, 4)  # More precision for low-priced assets
            
        # Ensure minimum trade size
        if quantity * current_price < 10:  # Minimum $10 trade
            logger.debug(f"Trade size too small: ${quantity * current_price:.2f}, minimum is $10")
            return 0
            
        logger.debug(f"Calculated position size: {quantity} units at ${current_price:.2f}/unit")
        return quantity
    
    def _enter_position(self, 
                       analysis_result,
                       current_date: datetime,
                       current_bar: pd.Series,
                       position_size: float,
                       params: BacktestParameters) -> Dict:
        """
        Enter a new position based on analysis result.
        
        Args:
            analysis_result: Analysis result from scanner
            current_date: Current date
            current_bar: Current price bar
            position_size: Position size to trade
            params: Backtest parameters
            
        Returns:
            Dictionary containing position information
        """
        # Extract signal and guidance information
        signal = analysis_result.signal
        guidance = analysis_result.position_guidance
        signal_type = signal.get('signal', 'neutral')
        
        # Determine direction
        is_buy_signal = 'buy' in signal_type
        direction = 'long' if is_buy_signal else 'short'
        
        # Get entry price (use current bar's price)
        entry_price = current_bar[params.price_source]
        
        # Get stop loss and take profit from position guidance
        stop_price = guidance.get('stop_loss')
        target_price = guidance.get('target_price')
        
        # If guidance doesn't provide these, calculate them
        if stop_price is None or target_price is None:
            # Calculate based on ATR if available
            atr = self._calculate_atr(current_bar, analysis_result, params)
            
            if direction == 'long':
                stop_price = entry_price * (1 - 0.02)  # Default 2% stop
                if atr > 0:
                    stop_price = entry_price - (2 * atr)  # 2 ATR stop
                    
                # Take profit based on risk:reward ratio
                risk = entry_price - stop_price
                target_price = entry_price + (risk * params.take_profit_multiplier)
                
            else:  # short
                stop_price = entry_price * (1 + 0.02)  # Default 2% stop
                if atr > 0:
                    stop_price = entry_price + (2 * atr)  # 2 ATR stop
                    
                # Take profit based on risk:reward ratio
                risk = stop_price - entry_price
                target_price = entry_price - (risk * params.take_profit_multiplier)
        
        # Calculate allocated capital
        allocated_capital = position_size * entry_price
        
        # Create position dictionary with all relevant data
        position = {
            'symbol': params.symbol,
            'direction': direction,
            'entry_date': current_date,
            'entry_price': entry_price,
            'current_price': entry_price,
            'stop_loss': stop_price,
            'take_profit': target_price,
            'quantity': position_size,
            'allocated_capital': allocated_capital,
            'current_value': allocated_capital,
            'signal_type': signal_type,
            'signal_strength': signal.get('strength', 0),
            'signal_alignment': signal.get('alignment', 0),
            'signal_confidence': signal.get('confidence', 'medium'),
            'cycles': analysis_result.detected_cycles,
            'cycle_states': analysis_result.cycle_states
        }
        
        logger.debug(f"Entered new {direction} position: {position_size} units at {entry_price:.2f}, "
                   f"stop: {stop_price:.2f}, target: {target_price:.2f}")
        
        return position
    
    def _update_positions(self, 
                         positions: Dict, 
                         current_bar: pd.Series, 
                         current_date: datetime,
                         params: BacktestParameters) -> Dict:
        """
        Update open positions based on current market data.
        
        Args:
            positions: Dictionary of open positions
            current_bar: Current price bar
            current_date: Current date
            params: Backtest parameters
            
        Returns:
            Dictionary with updated positions and closed trades
        """
        # Initialize return values
        closed_positions = []
        closed_trades = []
        allocated_capital = 0
        original_capital = 0
        
        # Get price data
        current_high = current_bar['high']
        current_low = current_bar['low']
        current_close = current_bar['close']
        
        # Process each position
        for position_id, position in list(positions.items()):
            direction = position['direction']
            entry_price = position['entry_price']
            stop_loss = position['stop_loss']
            take_profit = position['take_profit']
            quantity = position['quantity']
            allocated_value = position['allocated_capital']
            
            # Track original capital
            original_capital += allocated_value
            
            # Update current price and value
            position['current_price'] = current_close
            position['current_value'] = quantity * current_close
            
            # Check for stops and targets
            hit_stop = False
            hit_target = False
            exit_price = None
            exit_reason = None
            
            # Long position logic
            if direction == 'long':
                # Stop loss (check if price went below stop)
                if current_low <= stop_loss:
                    hit_stop = True
                    exit_price = stop_loss  # Assume filled at stop price
                    exit_reason = "stop_loss"
                    
                # Take profit (check if price went above target)
                elif current_high >= take_profit:
                    hit_target = True
                    exit_price = take_profit  # Assume filled at target price
                    exit_reason = "take_profit"
                    
                # Update trailing stop if enabled
                elif params.trailing_stop:
                    # Calculate new potential stop level
                    new_stop = current_close * (1 - params.trailing_stop_pct/100)
                    
                    # Move stop up if price has moved in our favor (never move it down)
                    if new_stop > stop_loss:
                        position['stop_loss'] = new_stop
                        logger.debug(f"Updated trailing stop to {new_stop:.2f} for {position_id}")
            
            # Short position logic
            else:  # direction == 'short'
                # Stop loss (check if price went above stop)
                if current_high >= stop_loss:
                    hit_stop = True
                    exit_price = stop_loss  # Assume filled at stop price
                    exit_reason = "stop_loss"
                    
                # Take profit (check if price went below target)
                elif current_low <= take_profit:
                    hit_target = True
                    exit_price = take_profit  # Assume filled at target price
                    exit_reason = "take_profit"
                    
                # Update trailing stop if enabled
                elif params.trailing_stop:
                    # Calculate new potential stop level
                    new_stop = current_close * (1 + params.trailing_stop_pct/100)
                    
                    # Move stop down if price has moved in our favor (never move it up)
                    if new_stop < stop_loss:
                        position['stop_loss'] = new_stop
                        logger.debug(f"Updated trailing stop to {new_stop:.2f} for {position_id}")
            
            # Process position exit if needed
            if hit_stop or hit_target:
                # Use the determined exit price
                if exit_price is None:
                    exit_price = current_close
                
                # Calculate profit/loss
                if direction == 'long':
                    profit_loss = (exit_price - entry_price) * quantity
                else:  # short
                    profit_loss = (entry_price - exit_price) * quantity
                
                # Apply commission
                commission = (exit_price * quantity) * (params.commission_pct / 100)
                profit_loss -= commission
                
                # Calculate percentage gain/loss
                profit_loss_pct = (profit_loss / allocated_value) * 100
                
                # Create trade record
                trade = BacktestTrade(
                    symbol=params.symbol,
                    direction=direction,
                    entry_date=position['entry_date'],
                    entry_price=entry_price,
                    exit_date=current_date,
                    exit_price=exit_price,
                    quantity=quantity,
                    profit_loss=profit_loss,
                    profit_loss_pct=profit_loss_pct,
                    exit_reason=exit_reason,
                    signal_strength=position.get('signal_strength', 0),
                    signal_alignment=position.get('signal_alignment', 0),
                    cycles=position.get('cycles', [])
                )
                
                # Record the closed position and trade
                closed_positions.append(position_id)
                closed_trades.append(trade)
                
                # Log the trade
                logger.info(f"Closed {direction} position after {(current_date - position['entry_date']).days} days: "
                           f"P&L: ${profit_loss:.2f} ({profit_loss_pct:.2f}%), "
                           f"Reason: {exit_reason}")
                
                # Remove from positions dictionary
                del positions[position_id]
            else:
                # Position still open - count allocated capital
                allocated_capital += position['current_value']
        
        # Calculate capital changes from closed positions
        capital_from_closed = 0
        for trade in closed_trades:
            capital_from_closed += trade.quantity * trade.entry_price + trade.profit_loss
        
        # Calculate updated total capital
        # Original capital + profits from closed positions - commissions (included in profit_loss)
        updated_capital = original_capital - allocated_capital + capital_from_closed
        
        return {
            'closed_positions': closed_positions,
            'closed_trades': closed_trades,
            'allocated_capital': allocated_capital,
            'updated_capital': updated_capital
        }
    
    def _calculate_atr(self, current_bar, analysis_result, params, period=14):
        """
        Calculate Average True Range for risk management.
        
        Args:
            current_bar: Current price bar
            analysis_result: Analysis result
            params: Backtest parameters
            period: ATR period
            
        Returns:
            ATR value or 0 if not available
        """
        # Try to get from analysis result if available
        if hasattr(analysis_result, 'data') and analysis_result.data is not None:
            data = analysis_result.data
            
            if len(data) >= period + 1:
                try:
                    # Calculate True Range
                    tr1 = data['high'] - data['low']
                    tr2 = abs(data['high'] - data['close'].shift(1))
                    tr3 = abs(data['low'] - data['close'].shift(1))
                    
                    tr = pd.DataFrame({
                        'tr1': tr1,
                        'tr2': tr2,
                        'tr3': tr3
                    }).max(axis=1)
                    
                    # Calculate ATR
                    atr = tr.rolling(period).mean().iloc[-1]
                    return atr
                except Exception as e:
                    logger.warning(f"Error calculating ATR: {e}")
                    
        # Fallback to a simpler volatility estimate
        return current_bar['high'] - current_bar['low']
    
    def _calculate_performance_metrics(self, 
                                     equity_curve: List[Dict],
                                     trades: List[BacktestTrade],
                                     params: BacktestParameters) -> Dict:
        """
        Calculate comprehensive performance metrics from backtest results.
        
        Args:
            equity_curve: List of equity data points
            trades: List of completed trades
            params: Backtest parameters
            
        Returns:
            Dictionary of performance metrics
        """
        try:
            # Ensure we have data to work with
            if not equity_curve or not trades:
                return self._empty_metrics()
                
            # Extract key data
            initial_capital = params.initial_capital
            final_capital = equity_curve[-1]['equity']
            total_return = final_capital - initial_capital
            total_return_pct = (total_return / initial_capital) * 100
            
            # Basic metrics
            total_trades = len(trades)
            winning_trades = sum(1 for t in trades if t.profit_loss > 0)
            losing_trades = total_trades - winning_trades
            win_rate = (winning_trades / total_trades) if total_trades > 0 else 0
            
            # Average trade metrics
            if winning_trades > 0:
                avg_winner = sum(t.profit_loss for t in trades if t.profit_loss > 0) / winning_trades
                avg_winner_pct = sum(t.profit_loss_pct for t in trades if t.profit_loss > 0) / winning_trades
            else:
                avg_winner = 0
                avg_winner_pct = 0
                
            if losing_trades > 0:
                avg_loser = sum(t.profit_loss for t in trades if t.profit_loss <= 0) / losing_trades
                avg_loser_pct = sum(t.profit_loss_pct for t in trades if t.profit_loss <= 0) / losing_trades
            else:
                avg_loser = 0
                avg_loser_pct = 0
                
            # Profit factor
            gross_profit = sum(max(0, t.profit_loss) for t in trades)
            gross_loss = sum(abs(min(0, t.profit_loss)) for t in trades)
            profit_factor = (gross_profit / gross_loss) if gross_loss != 0 else float('inf')
            
            # Extract dates and equity values
            dates = [e['date'] for e in equity_curve]
            equity_values = [e['equity'] for e in equity_curve]
            
            # Calculate drawdown metrics
            drawdowns, max_drawdown, max_drawdown_pct = self._calculate_drawdowns(equity_values)
            
            # Recovery factor
            if max_drawdown > 0:
                recovery_factor = abs(total_return / max_drawdown)
            else:
                recovery_factor = float('inf')
                
            # Sharpe ratio (annualized)
            if len(equity_values) > 1:
                returns = np.diff(equity_values) / equity_values[:-1]
                annualization_factor = self._get_annualization_factor(params.interval)
                
                mean_return = np.mean(returns)
                std_return = np.std(returns)
                
                if std_return > 0:
                    sharpe_ratio = (mean_return / std_return) * np.sqrt(annualization_factor)
                else:
                    sharpe_ratio = 0
            else:
                sharpe_ratio = 0
                
            # Calculate time-based metrics
            if len(dates) > 1:
                trading_days = (dates[-1] - dates[0]).days
                if trading_days > 0:
                    # CAGR
                    years = trading_days / 365.0
                    if initial_capital > 0 and years > 0:
                        cagr = ((final_capital / initial_capital) ** (1 / years) - 1) * 100
                    else:
                        cagr = 0
                        
                    # Average trade duration
                    durations = [(t.exit_date - t.entry_date).days for t in trades]
                    avg_trade_duration = sum(durations) / len(durations) if durations else 0
                    
                    # Trades per year
                    trades_per_year = (total_trades / years) if years > 0 else 0
                else:
                    cagr = 0
                    avg_trade_duration = 0
                    trades_per_year = 0
            else:
                cagr = 0
                avg_trade_duration = 0
                trades_per_year = 0
                
            # Collect monthly returns
            monthly_returns = self._calculate_monthly_returns(equity_curve)
            
            # Export all metrics
            metrics = {
                'total_trades': total_trades,
                'winning_trades': winning_trades,
                'losing_trades': losing_trades,
                'win_rate': win_rate,
                'profit_factor': profit_factor,
                'recovery_factor': recovery_factor,
                'total_return': total_return,
                'total_return_pct': total_return_pct,
                'cagr': cagr,
                'max_drawdown': max_drawdown,
                'max_drawdown_pct': max_drawdown_pct,
                'sharpe_ratio': sharpe_ratio,
                'avg_winner': avg_winner,
                'avg_winner_pct': avg_winner_pct,
                'avg_loser': avg_loser,
                'avg_loser_pct': avg_loser_pct,
                'avg_trade_duration': avg_trade_duration,
                'trades_per_year': trades_per_year,
                'monthly_returns': monthly_returns
            }
            
            # Add strategy-specific metrics if available
            metrics.update(self._calculate_strategy_metrics(trades, params))
            
            return metrics
            
        except Exception as e:
            logger.error(f"Error calculating performance metrics: {e}", exc_info=True)
            return self._empty_metrics()
    
    def _empty_metrics(self):
        """Return empty metrics dictionary for when no trades are made."""
        return {
            'total_trades': 0,
            'winning_trades': 0,
            'losing_trades': 0,
            'win_rate': 0,
            'profit_factor': 0,
            'recovery_factor': 0,
            'total_return': 0,
            'total_return_pct': 0,
            'cagr': 0,
            'max_drawdown': 0,
            'max_drawdown_pct': 0,
            'sharpe_ratio': 0,
            'avg_winner': 0,
            'avg_winner_pct': 0,
            'avg_loser': 0,
            'avg_loser_pct': 0,
            'avg_trade_duration': 0,
            'trades_per_year': 0,
            'monthly_returns': {}
        }
    
    def _calculate_drawdowns(self, equity_values):
        """
        Calculate drawdowns from equity curve.
        
        Args:
            equity_values: List of equity values
            
        Returns:
            Tuple of (drawdowns, max_drawdown, max_drawdown_pct)
        """
        try:
            if not equity_values or len(equity_values) < 2:
                return [], 0, 0
                
            # Calculate drawdowns
            equity_array = np.array(equity_values)
            hwm = np.maximum.accumulate(equity_array)
            drawdowns = (hwm - equity_array)
            drawdown_pcts = (drawdowns / hwm) * 100
            
            # Get maximum values
            max_drawdown = np.max(drawdowns)
            max_drawdown_pct = np.max(drawdown_pcts)
            
            return drawdowns.tolist(), float(max_drawdown), float(max_drawdown_pct)
            
        except Exception as e:
            logger.error(f"Error calculating drawdowns: {e}")
            return [], 0, 0
    
    def _calculate_monthly_returns(self, equity_curve):
        """
        Calculate monthly returns from equity curve.
        
        Args:
            equity_curve: List of equity data points
            
        Returns:
            Dictionary mapping month/year to percentage return
        """
        try:
            if not equity_curve or len(equity_curve) < 2:
                return {}
                
            # Group by month
            month_data = defaultdict(lambda: {'open': None, 'close': None})
            
            for point in equity_curve:
                date = point['date']
                month_key = (date.year, date.month)
                equity = point['equity']
                
                # First data point for month becomes the open
                if month_data[month_key]['open'] is None:
                    month_data[month_key]['open'] = equity
                    
                # Always update the close to the latest value
                month_data[month_key]['close'] = equity
            
            # Calculate returns
            monthly_returns = {}
            
            for month, values in month_data.items():
                try:
                    # Skip if we don't have opening value
                    if values['open'] is None:
                        continue
                        
                    # Avoid division by zero
                    if values['open'] == 0:
                        logger.warning(f"Zero opening equity for month {month[0]}-{month[1]}. Skipping.")
                        continue
                        
                    # Calculate return
                    monthly_return = ((values['close'] - values['open']) / values['open']) * 100
                    monthly_returns[month] = monthly_return
                    
                except Exception as month_err:
                    logger.error(f"Error calculating return for month {month[0]}-{month[1]}: {month_err}")
            
            return monthly_returns
            
        except Exception as e:
            logger.error(f"Error calculating monthly returns: {e}")
            return {}
    
    def _calculate_strategy_metrics(self, trades, params):
        """
        Calculate strategy-specific metrics.
        
        Args:
            trades: List of completed trades
            params: Backtest parameters
            
        Returns:
            Dictionary of strategy-specific metrics
        """
        # Initialize with empty metrics
        metrics = {}
        
        # Get the strategy if available
        strategy_name = params.strategy_type
        try:
            strategy = self.get_strategy_by_name(strategy_name)
            if strategy and hasattr(strategy, 'calculate_metrics'):
                # Let the strategy calculate its own metrics
                strategy_metrics = strategy.calculate_metrics(trades, params)
                metrics.update(strategy_metrics)
        except Exception as e:
            logger.warning(f"Error calculating strategy-specific metrics: {e}")
        
        return metrics
    
    def _get_annualization_factor(self, interval):
        """
        Get annualization factor based on interval.
        
        Args:
            interval: Time interval
            
        Returns:
            Annualization factor
        """
        factors = {
            '1m': 252 * 6.5 * 60,  # Assuming 252 trading days, 6.5 hours per day
            '5m': 252 * 6.5 * 12,
            '15m': 252 * 6.5 * 4,
            '30m': 252 * 6.5 * 2,
            '1h': 252 * 6.5,
            '4h': 252 * 1.625,
            'daily': 252,
            'weekly': 52,
            'monthly': 12
        }
        
        return factors.get(interval, 252)  # Default to daily
    
    def _params_to_dict(self, params):
        """Convert parameters to dictionary for storage."""
        if hasattr(params, '__dict__'):
            result = params.__dict__.copy()
            
            # Convert datetime objects to strings
            for key, value in result.items():
                if isinstance(value, datetime):
                    result[key] = value.isoformat()
                    
            return result
        return {}
    
    def _trade_to_dict(self, trade):
        """Convert trade object to dictionary for storage."""
        if hasattr(trade, '__dict__'):
            result = trade.__dict__.copy()
            
            # Convert datetime objects to strings
            for key, value in result.items():
                if isinstance(value, datetime):
                    result[key] = value.isoformat()
                    
            return result
        return {}
    
    def save_results(self, results, file_path):
        """
        Save backtest results to file.
        
        Args:
            results: Backtest results dictionary
            file_path: Path to save results
        """
        try:
            # Ensure the directory exists
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            
            # Serialize to JSON
            with open(file_path, 'w') as f:
                json.dump(results, f, indent=2)
                
            logger.info(f"Saved backtest results to {file_path}")
            
        except Exception as e:
            logger.error(f"Error saving results: {e}")
    
    def load_results(self, file_path):
        """
        Load backtest results from file.
        
        Args:
            file_path: Path to load results from
            
        Returns:
            Backtest results dictionary
        """
        try:
            with open(file_path, 'r') as f:
                results = json.load(f)
                
            logger.info(f"Loaded backtest results from {file_path}")
            return results
            
        except Exception as e:
            logger.error(f"Error loading results: {e}")
            return None
            
    def plot_equity_curve(self, results, figsize=(12, 8), save_path=None):
        """
        Plot equity curve from backtest results.
        
        Args:
            results: Backtest results dictionary
            figsize: Figure size tuple (width, height)
            save_path: Optional path to save the plot
            
        Returns:
            Matplotlib figure
        """
        try:
            # Check for valid results
            if not results or 'equity_curve' not in results or not results['equity_curve']:
                logger.warning("No equity curve data to plot")
                return None
                
            # Extract data
            equity_curve = results['equity_curve']
            dates = [pd.Timestamp(e['date']) if isinstance(e['date'], str) else e['date'] 
                   for e in equity_curve]
            equity = [e['equity'] for e in equity_curve]
            
            # Create figure and axes
            fig, axes = plt.subplots(2, 1, figsize=figsize, gridspec_kw={'height_ratios': [3, 1]})
            
            # Plot equity curve
            axes[0].plot(dates, equity, label='Equity', color='blue', linewidth=2)
            axes[0].set_title(f"Equity Curve: {results['symbol']} ({results['interval']})")
            axes[0].grid(True, alpha=0.3)
            axes[0].set_ylabel('Equity')
            axes[0].axhline(y=results['initial_capital'], color='gray', linestyle='--', 
                         label=f"Initial Capital ({results['initial_capital']})")
            
            # Add trades markers if available
            if 'trades' in results and results['trades']:
                for trade in results['trades']:
                    # Convert dates if strings
                    entry_date = pd.Timestamp(trade['entry_date']) if isinstance(trade['entry_date'], str) else trade['entry_date']
                    exit_date = pd.Timestamp(trade['exit_date']) if isinstance(trade['exit_date'], str) else trade['exit_date']
                    
                    # Find nearest equity values
                    entry_idx = min(range(len(dates)), key=lambda i: abs((dates[i] - entry_date).total_seconds()))
                    exit_idx = min(range(len(dates)), key=lambda i: abs((dates[i] - exit_date).total_seconds()))
                    
                    # Get equity values
                    entry_equity = equity[entry_idx]
                    exit_equity = equity[exit_idx]
                    
                    # Set color based on profit/loss
                    color = 'green' if trade['profit_loss'] > 0 else 'red'
                    
                    # Plot markers
                    axes[0].scatter(entry_date, entry_equity, color=color, marker='^', s=50, alpha=0.7)
                    axes[0].scatter(exit_date, exit_equity, color=color, marker='v', s=50, alpha=0.7)
                    
                    # Connect with line
                    axes[0].plot([entry_date, exit_date], [entry_equity, exit_equity], color=color, alpha=0.3)
            
            # Add metrics box
            metrics = results['metrics']
            metrics_text = (
                f"Total Return: {metrics['total_return_pct']:.2f}%\n"
                f"Win Rate: {metrics['win_rate']*100:.2f}%\n"
                f"Profit Factor: {metrics['profit_factor']:.2f}\n"
                f"Max Drawdown: {metrics['max_drawdown_pct']:.2f}%\n"
                f"Sharpe Ratio: {metrics['sharpe_ratio']:.2f}"
            )
            
            # Add text box
            props = dict(boxstyle='round', facecolor='white', alpha=0.7)
            axes[0].text(0.02, 0.98, metrics_text, transform=axes[0].transAxes, fontsize=10,
                      verticalalignment='top', bbox=props)
            
            # Plot drawdowns
            if 'drawdowns' in metrics:
                drawdowns = metrics['drawdowns']
            else:
                # Calculate drawdowns
                equity_array = np.array(equity)
                hwm = np.maximum.accumulate(equity_array)
                drawdowns = (hwm - equity_array) / hwm * 100  # percentage
                
            # Plot actual drawdowns
            axes[1].fill_between(dates, 0, drawdowns, color='red', alpha=0.3)
            axes[1].set_title('Drawdowns (%)')
            axes[1].set_ylabel('Drawdown %')
            axes[1].grid(True, alpha=0.3)
            axes[1].set_xlabel('Date')
            # Invert y-axis for more intuitive display
            axes[1].invert_yaxis()
            
            # Adjust layout
            plt.tight_layout()
            
            # Save if requested
            if save_path:
                plt.savefig(save_path, dpi=300, bbox_inches='tight')
                logger.info(f"Saved equity curve plot to {save_path}")
            
            return fig
            
        except Exception as e:
            logger.error(f"Error plotting equity curve: {e}", exc_info=True)
            return None


# Utility Functions

def run_quick_backtest(symbol, exchange, interval, strategy_type='fib_cycle', 
                      start_date=None, end_date=None, lookback=1000, initial_capital=100000):
    """
    Run a quick backtest with minimal setup.
    
    Args:
        symbol: Symbol to backtest
        exchange: Exchange
        interval: Time interval
        strategy_type: Strategy name
        start_date: Optional start date
        end_date: Optional end date
        lookback: Lookback period
        initial_capital: Initial capital
        
    Returns:
        Backtest results dictionary
    """
    import os
    import json
    
    # Load config
    config_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'config', 'config.json')
    with open(config_path, 'r') as f:
        config = json.load(f)
    
    # Create engine and parameters
    engine = BacktestEngine(config)
    
    # Parse dates
    if isinstance(start_date, str):
        start_date = pd.Timestamp(start_date)
    if isinstance(end_date, str):
        end_date = pd.Timestamp(end_date)
    
    # Create parameters
    params = BacktestParameters(
        symbol=symbol,
        exchange=exchange,
        interval=interval,
        start_date=start_date,
        end_date=end_date,
        lookback=lookback,
        initial_capital=initial_capital,
        position_size_pct=10.0,
        max_open_positions=5,
        min_strength=0.2,
        strategy_type=strategy_type
    )
    
    # Run the backtest
    results = engine.run_backtest(params)
    
    return results


def compare_strategies(symbol, exchange, interval, strategy_types, 
                      start_date=None, end_date=None, plot=True):
    """
    Compare multiple strategies on the same instrument.
    
    Args:
        symbol: Symbol to backtest
        exchange: Exchange
        interval: Time interval
        strategy_types: List of strategy names to test
        start_date: Optional start date
        end_date: Optional end date
        plot: Whether to plot the results
        
    Returns:
        Dictionary of backtest results for each strategy
    """
    results = {}
    
    # Run backtest for each strategy
    for strategy in strategy_types:
        result = run_quick_backtest(
            symbol=symbol,
            exchange=exchange,
            interval=interval,
            strategy_type=strategy,
            start_date=start_date,
            end_date=end_date
        )
        
        results[strategy] = result
    
    # Plot comparison if requested
    if plot and results:
        _plot_strategy_comparison(results)
    
    return results


def _plot_strategy_comparison(results_dict):
    """
    Plot comparison of multiple strategies.
    
    Args:
        results_dict: Dictionary mapping strategy names to backtest results
    """
    import matplotlib.pyplot as plt
    
    # Create figure
    fig, ax = plt.subplots(figsize=(12, 8))
    
    # Plot equity curves for each strategy
    for strategy_name, results in results_dict.items():
        if not results or 'equity_curve' not in results or not results['equity_curve']:
            continue
            
        # Extract data
        equity_curve = results['equity_curve']
        dates = [pd.Timestamp(e['date']) if isinstance(e['date'], str) else e['date'] 
               for e in equity_curve]
        equity = [e['equity'] for e in equity_curve]
        
        # Normalize to percentage return
        initial_capital = results['initial_capital']
        equity_pct = [(e / initial_capital - 1) * 100 for e in equity]
        
        # Plot this strategy
        ax.plot(dates, equity_pct, label=f"{strategy_name}", linewidth=2)
    
    # Add details
    symbol = next(iter(results_dict.values()))['symbol']
    interval = next(iter(results_dict.values()))['interval']
    
    ax.set_title(f"Strategy Comparison: {symbol} ({interval})")
    ax.grid(True, alpha=0.3)
    ax.set_ylabel('Return (%)')
    ax.set_xlabel('Date')
    ax.axhline(y=0, color='gray', linestyle='--')
    ax.legend()
    
    # Add performance metrics table
    performance_data = []
    for strategy, results in results_dict.items():
        if 'metrics' in results:
            metrics = results['metrics']
            performance_data.append({
                'Strategy': strategy,
                'Return (%)': f"{metrics['total_return_pct']:.2f}",
                'CAGR (%)': f"{metrics['cagr']:.2f}",
                'Win Rate (%)': f"{metrics['win_rate']*100:.2f}",
                'Profit Factor': f"{metrics['profit_factor']:.2f}",
                'Max DD (%)': f"{metrics['max_drawdown_pct']:.2f}",
                'Sharpe': f"{metrics['sharpe_ratio']:.2f}",
                'Trades': metrics['total_trades']
            })
    
    if performance_data:
        plt.table(
            cellText=[[d[k] for k in d if k != 'Strategy'] for d in performance_data],
            rowLabels=[d['Strategy'] for d in performance_data],
            colLabels=[k for k in performance_data[0] if k != 'Strategy'],
            cellLoc='center',
            loc='bottom',
            bbox=[0, -0.35, 1, 0.25]
        )
        
        # Make room for the table
        plt.subplots_adjust(bottom=0.25)
    
    plt.tight_layout()
    return fig